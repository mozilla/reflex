var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;
    
    require.define = function (filename, fn) {
        if (!definedProcess && require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
            definedProcess = true;
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process','global'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\n//@ sourceURL=path"
));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process','global'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n        && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return window.setImmediate;\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\n//@ sourceURL=__browserify_process"
));

require.define("/node_modules/reducers/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/reducers/package.json"
));

require.define("/node_modules/reducers/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\n// Consumption\nexports.fold = require(\"./fold\")\n\n// Transformation\nexports.filter = require(\"./filter\")\nexports.map = require(\"./map\")\nexports.reductions = require(\"./reductions\")\n\n// Combining streams\nexports.concat = require(\"./concat\")\nexports.merge = require(\"./merge\")\n\n// Error handling\nexports.capture = require(\"./capture\")\nexports.delay = require(\"./delay\")\n\n// Size changes\nexports.dropWhile = require(\"./drop-while\")\nexports.drop = require(\"./drop\")\nexports.takeWhile = require(\"./take-while\")\nexports.take = require(\"./take\")\n\n// Multiplexing / sharing transformations\nexports.hub = require(\"./hub\")\n\n// Development / debug\nexports.print = require(\"./debug/print\")\nexports.into = require(\"./into\")\n\n// Transformation helper\nexports.reducer = require(\"./reducer\")\n\n//@ sourceURL=/node_modules/reducers/index.js"
));

require.define("/node_modules/reducers/fold.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar reduce = require(\"reducible/reduce\")\nvar isError = require(\"reducible/is-error\")\nvar isReduced = require(\"reducible/is-reduced\")\nvar end = require(\"reducible/end\")\n\nvar Eventual = require(\"eventual/type\")\nvar deliver = require(\"eventual/deliver\")\nvar defer = require(\"eventual/defer\")\nvar when = require(\"eventual/when\")\n\n\n// All eventual values are reduced same as the values they realize to.\nreduce.define(Eventual, function reduceEventual(eventual, next, initial) {\n  return when(eventual, function delivered(value) {\n    return reduce(value, next, initial)\n  }, function failed(error) {\n    next(error, initial)\n    return error\n  })\n})\n\n\nfunction fold(source, next, initial) {\n  /**\n  Fold is just like `reduce` with a difference that `next` reducer / folder\n  function it takes has it's parameters reversed. One always needs `value`,\n  but not always accumulated one. To avoid conflict with array `reduce` we\n  have a `fold`.\n  **/\n  var promise = defer()\n  reduce(source, function fold(value, state) {\n    // If source is `end`-ed deliver accumulated `state`.\n    if (value === end) return deliver(promise, state)\n    // If is source has an error, deliver that.\n    else if (isError(value)) return deliver(promise, value)\n\n    // Accumulate new `state`\n    try { state = next(value, state) }\n    // If exception is thrown at accumulation deliver thrown error.\n    catch (error) { return deliver(promise, error) }\n\n    // If already reduced, then deliver.\n    if (isReduced(state)) deliver(promise, state.value)\n\n    return state\n  }, initial)\n\n  // Wrap in `when` in case `promise` is already delivered to return an\n  // actual value.\n  return when(promise)\n}\n\nmodule.exports = fold\n\n//@ sourceURL=/node_modules/reducers/fold.js"
));

require.define("/node_modules/reducible/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./reducible.js\"}\n//@ sourceURL=/node_modules/reducible/package.json"
));

require.define("/node_modules/reducible/reduce.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar method = require(\"method\")\n\nvar isReduced = require(\"./is-reduced\")\nvar isError = require(\"./is-error\")\nvar end = require(\"./end\")\n\nvar reduce = method(\"reduce\")\n\n// Implementation of `reduce` for the empty collections, that immediately\n// signals reducer that it's ended.\nreduce.empty = function reduceEmpty(empty, next, initial) {\n  next(end, initial)\n}\n\n// Implementation of `reduce` for the singular values which are treated\n// as collections with a single element. Yields a value and signals the end.\nreduce.singular = function reduceSingular(value, next, initial) {\n  next(end, next(value, initial))\n}\n\n// Implementation of `reduce` for the array (and alike) values, such that it\n// will call accumulator function `next` each time with next item and\n// accumulated state until it's exhausted or `next` returns marked value\n// indicating that it's reduced. Either way signals `end` to an accumulator.\nreduce.indexed = function reduceIndexed(indexed, next, initial) {\n  var state = initial\n  var index = 0\n  var count = indexed.length\n  while (index < count) {\n    var value = indexed[index]\n    state = next(value, state)\n    index = index + 1\n    if (value === end) return end\n    if (isError(value)) return state\n    if (isReduced(state)) return state.value\n  }\n  next(end, state)\n}\n\n// Both `undefined` and `null` implement accumulate for empty sequences.\nreduce.define(void(0), reduce.empty)\nreduce.define(null, reduce.empty)\n\n// Array and arguments implement accumulate for indexed sequences.\nreduce.define(Array, reduce.indexed)\n\nfunction Arguments() { return arguments }\nArguments.prototype = Arguments()\nreduce.define(Arguments, reduce.indexed)\n\n// All other built-in data types are treated as single value collections\n// by default. Of course individual types may choose to override that.\nreduce.define(reduce.singular)\n\n// Errors just yield that error.\nreduce.define(Error, function(error, next) { next(error) })\nmodule.exports = reduce\n\n//@ sourceURL=/node_modules/reducible/reduce.js"
));

require.define("/node_modules/method/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./core.js\"}\n//@ sourceURL=/node_modules/method/package.json"
));

require.define("/node_modules/method/core.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar defineProperty = Object.defineProperty || function(object, name, property) {\n  object[name] = property.value\n  return object\n}\n\n// Shortcut for `Object.prototype.toString` for faster access.\nvar typefy = Object.prototype.toString\n\n// Map to for jumping from typeof(value) to associated type prefix used\n// as a hash in the map of builtin implementations.\nvar types = { \"function\": \"Object\", \"object\": \"Object\" }\n\n// Array is used to save method implementations for the host objects in order\n// to avoid extending them with non-primitive values that could cause leaks.\nvar host = []\n// Hash map is used to save method implementations for builtin types in order\n// to avoid extending their prototypes. This also allows to share method\n// implementations for types across diff contexts / frames / compartments.\nvar builtin = {}\n\nfunction Primitive() {}\nfunction ObjectType() {}\nObjectType.prototype = new Primitive()\nfunction ErrorType() {}\nErrorType.prototype = new ObjectType()\n\nvar Default = builtin.Default = Primitive.prototype\nvar Null = builtin.Null = new Primitive()\nvar Void = builtin.Void = new Primitive()\nbuiltin.String = new Primitive()\nbuiltin.Number = new Primitive()\nbuiltin.Boolean = new Primitive()\n\nbuiltin.Object = ObjectType.prototype\nbuiltin.Error = ErrorType.prototype\n\nbuiltin.EvalError = new ErrorType()\nbuiltin.InternalError = new ErrorType()\nbuiltin.RangeError = new ErrorType()\nbuiltin.ReferenceError = new ErrorType()\nbuiltin.StopIteration = new ErrorType()\nbuiltin.SyntaxError = new ErrorType()\nbuiltin.TypeError = new ErrorType()\nbuiltin.URIError = new ErrorType()\n\n\nfunction Method(hint) {\n  /**\n  Private Method is a callable private name that dispatches on the first\n  arguments same named Method:\n\n      method(object, ...rest) => object[method](...rest)\n\n  Optionally hint string may be provided that will be used in generated names\n  to ease debugging.\n\n  ## Example\n\n      var foo = Method()\n\n      // Implementation for any types\n      foo.define(function(value, arg1, arg2) {\n        // ...\n      })\n\n      // Implementation for a specific type\n      foo.define(BarType, function(bar, arg1, arg2) {\n        // ...\n      })\n  **/\n\n  // Create an internal unique name if `hint` is provided it is used to\n  // prefix name to ease debugging.\n  var name = (hint || \"\") + \"#\" + Math.random().toString(32).substr(2)\n\n  function dispatch(value) {\n    // Method dispatches on type of the first argument.\n    // If first argument is `null` or `void` associated implementation is\n    // looked up in the `builtin` hash where implementations for built-ins\n    // are stored.\n    var type = null\n    var method = value === null ? Null[name] :\n                 value === void(0) ? Void[name] :\n                 // Otherwise attempt to use method with a generated private\n                 // `name` that is supposedly in the prototype chain of the\n                 // `target`.\n                 value[name] ||\n                 // Otherwise assume it's one of the built-in type instances,\n                 // in which case implementation is stored in a `builtin` hash.\n                 // Attempt to find a implementation for the given built-in\n                 // via constructor name and method name.\n                 ((type = builtin[(value.constructor || \"\").name]) &&\n                  type[name]) ||\n                 // Otherwise assume it's a host object. For host objects\n                 // actual method implementations are stored in the `host`\n                 // array and only index for the implementation is stored\n                 // in the host object's prototype chain. This avoids memory\n                 // leaks that otherwise could happen when saving JS objects\n                 // on host object.\n                 host[value[\"!\" + name]] ||\n                 // Otherwise attempt to lookup implementation for builtins by\n                 // a type of the value. This basically makes sure that all\n                 // non primitive values will delegate to an `Object`.\n                 ((type = builtin[types[typeof(value)]]) && type[name])\n\n\n    // If method implementation for the type is still not found then\n    // just fallback for default implementation.\n    method = method || Default[name]\n\n\n    // If implementation is still not found (which also means there is no\n    // default) just throw an error with a descriptive message.\n    if (!method) throw TypeError(\"Type does not implements method: \" + name)\n\n    // If implementation was found then just delegate.\n    return method.apply(method, arguments)\n  }\n\n  // Make `toString` of the dispatch return a private name, this enables\n  // method definition without sugar:\n  //\n  //    var method = Method()\n  //    object[method] = function() { /***/ }\n  dispatch.toString = function toString() { return name }\n\n  // Copy utility methods for convenient API.\n  dispatch.implement = implementMethod\n  dispatch.define = defineMethod\n\n  return dispatch\n}\n\n// Define `implement` and `define` polymorphic methods to allow definitions\n// and implementations through them.\nvar implement = Method(\"implement\")\nvar define = Method(\"define\")\n\n\nfunction _implement(method, object, lambda) {\n  /**\n  Implements `Method` for the given `object` with a provided `implementation`.\n  Calling `Method` with `object` as a first argument will dispatch on provided\n  implementation.\n  **/\n  return defineProperty(object, method.toString(), {\n    enumerable: false,\n    configurable: false,\n    writable: false,\n    value: lambda\n  })\n}\n\nfunction _define(method, Type, lambda) {\n  /**\n  Defines `Method` for the given `Type` with a provided `implementation`.\n  Calling `Method` with a first argument of this `Type` will dispatch on\n  provided `implementation`. If `Type` is a `Method` default implementation\n  is defined. If `Type` is a `null` or `undefined` `Method` is implemented\n  for that value type.\n  **/\n\n  // Attempt to guess a type via `Object.prototype.toString.call` hack.\n  var type = Type && typefy.call(Type.prototype)\n\n  // If only two arguments are passed then `Type` is actually an implementation\n  // for a default type.\n  if (!lambda) Default[method] = Type\n  // If `Type` is `null` or `void` store implementation accordingly.\n  else if (Type === null) Null[method] = lambda\n  else if (Type === void(0)) Void[method] = lambda\n  // If `type` hack indicates built-in type and type has a name us it to\n  // store a implementation into associated hash. If hash for this type does\n  // not exists yet create one.\n  else if (type !== \"[object Object]\" && Type.name) {\n    var Bulitin = builtin[Type.name] || (builtin[Type.name] = new ObjectType())\n    Bulitin[method] = lambda\n  }\n  // If `type` hack indicates an object, that may be either object or any\n  // JS defined \"Class\". If name of the constructor is `Object`, assume it's\n  // built-in `Object` and store implementation accordingly.\n  else if (Type.name === \"Object\")\n    builtin.Object[method] = lambda\n  // Host objects are pain!!! Every browser does some crazy stuff for them\n  // So far all browser seem to not implement `call` method for host object\n  // constructors. If that is a case here, assume it's a host object and\n  // store implementation in a `host` array and store `index` in the array\n  // in a `Type.prototype` itself. This avoids memory leaks that could be\n  // caused by storing JS objects on a host objects.\n  else if (Type.call === void(0)) {\n    var index = host.indexOf(lambda)\n    if (index < 0) index = host.push(lambda) - 1\n    // Prefix private name with `!` so it can be dispatched from the method\n    // without type checks.\n    implement(\"!\" + method, Type.prototype, index)\n  }\n  // If Got that far `Type` is user defined JS `Class`. Define private name\n  // as hidden property on it's prototype.\n  else\n    implement(method, Type.prototype, lambda)\n}\n\n// Create method shortcuts form functions.\nvar defineMethod = function defineMethod(Type, lambda) {\n  return _define(this, Type, lambda)\n}\nvar implementMethod = function implementMethod(object, lambda) {\n  return _implement(this, object, lambda)\n}\n\n// And provided implementations for a polymorphic equivalents.\n_define(define, _define)\n_define(implement, _implement)\n\n// Define exports on `Method` as it's only thing being exported.\nMethod.implement = implement\nMethod.define = define\nMethod.Method = Method\nMethod.builtin = builtin\nMethod.host = host\n\nmodule.exports = Method\n\n//@ sourceURL=/node_modules/method/core.js"
));

require.define("/node_modules/reducible/is-reduced.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar reduced = require(\"./reduced\")\n\nfunction isReduced(value) {\n  return value && value.is === reduced\n}\n\nmodule.exports = isReduced\n\n//@ sourceURL=/node_modules/reducible/is-reduced.js"
));

require.define("/node_modules/reducible/reduced.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\n\n// Exported function can be used for boxing values. This boxing indicates\n// that consumer of sequence has finished consuming it, there for new values\n// should not be no longer pushed.\nfunction reduced(value) {\n  /**\n  Boxes given value and indicates to a source that it's already reduced and\n  no new values should be supplied\n  **/\n  return { value: value, is: reduced }\n}\n\nmodule.exports = reduced\n\n//@ sourceURL=/node_modules/reducible/reduced.js"
));

require.define("/node_modules/reducible/is-error.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar stringifier = Object.prototype.toString\n\nfunction isError(value) {\n  return stringifier.call(value) === \"[object Error]\"\n}\n\nmodule.exports = isError\n\n//@ sourceURL=/node_modules/reducible/is-error.js"
));

require.define("/node_modules/reducible/end.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nmodule.exports = String(\"End of the collection\")\n\n//@ sourceURL=/node_modules/reducible/end.js"
));

require.define("/node_modules/reducers/node_modules/eventual/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./index.js\"}\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/package.json"
));

require.define("/node_modules/reducers/node_modules/eventual/type.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar watchers = require(\"watchables/watchers\")\nvar watch = require(\"watchables/watch\")\nvar await = require(\"pending/await\")\nvar isPending = require(\"pending/is\")\nvar deliver = require(\"./deliver\")\nvar when = require(\"./when\")\n\n// Internal utility function returns true if given value is of error type,\n// otherwise returns false.\nvar isError = (function() {\n  var stringy = Object.prototype.toString\n  var error = stringy.call(Error.prototype)\n  return function isError(value) {\n    return stringy.call(value) === error\n  }\n})()\n\n// Internal utility, identity function. Returns whatever is given to it.\nfunction identity(value) { return value }\n\n// Internal utility, decorator function that wraps given function into\n// try / catch and returns thrown exception in case when exception is\n// thrown.\nfunction attempt(f) {\n  return function effort(value) {\n    try { return f(value) }\n    catch (error) { return error }\n  }\n}\n\n\n// Define property names used by an `Eventual` type. Names are prefixed via\n// `module.id` to avoid name conflicts.\nvar observers = \"observers@\" + module.id\nvar result = \"value@\" + module.id\nvar pending = \"pending@\" + module.id\n\n\nfunction Eventual() {\n  /**\n  Data type representing eventual value, that can be observed and delivered.\n  Type implements `watchable`, `pending` and `eventual` abstractions, where\n  first two are defined in an external libraries.\n  **/\n  this[observers] = []\n  this[result] = this\n  this[pending] = true\n}\n// Expose property names via type static properties so that it's easier\n// to refer to them while debugging.\nEventual.observers = observers\nEventual.result = result\nEventual.pending = pending\n\nwatchers.define(Eventual, function(value) {\n  return value[observers]\n})\n// Eventual values considered to be pending until the are deliver by calling\n// `deliver`. Internal `pending` property is used to identify weather value\n// is being watched or not.\nisPending.define(Eventual, function(value) {\n  return value[pending]\n})\n// Eventual type implements await function of pending abstraction, to enable\n// observation of value delivery.\nawait.define(Eventual, function(value, observer) {\n  if (isPending(value)) watch(value, observer)\n  else observer(value[result])\n})\n\n// Eventual implements `deliver` function of pending abstraction, to enable\n// fulfillment of eventual values. Eventual value can be delivered only once,\n// which will transition it from pending state to non-pending state. All\n// further deliveries are ignored. It's also guaranteed that all the registered\n// observers will be invoked in FIFO order.\ndeliver.define(Eventual, function(value, data) {\n  // Ignore delivery if value is no longer pending, or if it's in a process of\n  // delivery (in this case eventual[result] is set to value other than\n  // eventual itself). Also ignore if data deliver is value itself.\n  if (value !== data && isPending(value) && value[result] === value) {\n    var count = 0\n    var index = 0\n    var delivering = true\n    var observers = void(0)\n    // Set eventual value result to passed data value that also marks value\n    // as delivery in progress. This way all the `deliver` calls is side\n    // effect to this will be ignored. Note: value should still remain pending\n    // so that new observers could be registered instead of being called\n    // immediately, otherwise it breaks FIFO order.\n    value[result] = data\n    while (delivering) {\n      // If current batch of observers is exhausted, splice a new batch\n      // and continue delivery. New batch is created only if new observers\n      // are registered in side effect to this call of deliver.\n      if (index === count) {\n        observers = watchers(value).splice(0)\n        count = observers.length\n        index = 0\n        // If new observers have not being registered mark value as no longer\n        // pending and finish delivering.\n        if (count === index) {\n          value[pending] = false\n          delivering = false\n        }\n      }\n      // Register await handlers on given result, is it may be eventual /\n      // pending itself. Delivering eventual will cause delivery of the\n      // delivered eventual's delivery value, whenever that would be.\n      else {\n        await(data, observers[index])\n        index = index + 1\n      }\n    }\n  }\n})\n\n// Eventual implements `when` polymorphic function that is part of it's own\n// abstraction. It takes `value` `onFulfill` & `onError` handlers. In return\n// when returns eventual value, that is delivered return value of the handler\n// that is invoked depending on the given values delivery. If deliver value\n// is of error type error handler is invoked. If value is delivered with other\n// non-pending value that is not of error type `onFulfill` handlers is invoked\n// with it. If pending value is delivered then it's value will be delivered\n// it's result whenever that would be. This will cause both value and error\n// propagation.\nwhen.define(Eventual, function(value, onRealize, onError) {\n  // Create eventual value for a return value.\n  var delivered = false\n  var eventual = void(0)\n  var result = void(0)\n  // Wrap handlers into attempt decorator function, so that in case of\n  // exception thrown error is returned causing error propagation. If handler\n  // is missing identity function is used instead to propagate value / error.\n  var realize = onRealize ? attempt(onRealize) : identity\n  var error = onError ? attempt(onError) : identity\n  // Wait for pending value to be delivered.\n  await(value, function onDeliver(data) {\n    // Once value is delivered invoke appropriate handler, and deliver it\n    // to a resulting eventual value.\n    result = isError(data) ? error(data)\n                           : realize(data)\n\n    // If outer function is already returned and has created eventual\n    // for it's result deliver it. Otherwise (if await called observer\n    // in same synchronously) mark result delivered.\n    if (eventual) deliver(eventual, result)\n    else delivered = true\n  })\n\n  // If result is delivered already return it, otherwise create eventual\n  // value for the result and return that.\n  return delivered ? result : (eventual = new Eventual())\n})\n\nmodule.exports = Eventual\n\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/type.js"
));

require.define("/node_modules/reducers/node_modules/watchables/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./index.js\"}\n//@ sourceURL=/node_modules/reducers/node_modules/watchables/package.json"
));

require.define("/node_modules/reducers/node_modules/watchables/watchers.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar method = require(\"method\")\n\n// Method is supposed to return array of watchers for the given\n// value.\nvar watchers = method(\"watchers\")\nmodule.exports = watchers\n\n//@ sourceURL=/node_modules/reducers/node_modules/watchables/watchers.js"
));

require.define("/node_modules/reducers/node_modules/watchables/watch.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar method = require(\"method\")\nvar watchers = require(\"./watchers\")\n\nvar watch = method(\"watch\")\nwatch.define(function(value, watcher) {\n  // Registers a `value` `watcher`, unless it\"s already registered.\n  var registered = watchers(value)\n  if (registered && registered.indexOf(watcher) < 0)\n    registered.push(watcher)\n  return value\n})\n\nmodule.exports = watch\n\n//@ sourceURL=/node_modules/reducers/node_modules/watchables/watch.js"
));

require.define("/node_modules/reducers/node_modules/eventual/node_modules/pending/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./index.js\"}\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/node_modules/pending/package.json"
));

require.define("/node_modules/reducers/node_modules/eventual/node_modules/pending/await.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar method = require(\"method\")\n\n// Set's up a callback to be called once pending\n// value is realized. All object by default are realized.\nvar await = method(\"await\")\nawait.define(function(value, callback) { callback(value) })\n\nmodule.exports = await\n\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/node_modules/pending/await.js"
));

require.define("/node_modules/reducers/node_modules/eventual/node_modules/pending/is.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar method = require(\"method\")\n\n// Returns `true` if given `value` is pending, otherwise returns\n// `false`. All types will return false unless type specific\n// implementation is provided to do it otherwise.\nvar isPending = method(\"is-pending\")\n\nisPending.define(function() { return false })\n\nmodule.exports = isPending\n\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/node_modules/pending/is.js"
));

require.define("/node_modules/reducers/node_modules/eventual/deliver.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\n// Anyone crating an eventual will likely need to realize it, requiring\n// dependency on other package is complicated, not to mention that one\n// can easily wind up with several copies that does not necessary play\n// well with each other. Exposing this solves the issues.\nmodule.exports = require(\"pending/deliver\")\n\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/deliver.js"
));

require.define("/node_modules/reducers/node_modules/eventual/node_modules/pending/deliver.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar method = require(\"method\")\n// Method delivers pending value.\nvar deliver = method(\"deliver\")\n\nmodule.exports = deliver\n\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/node_modules/pending/deliver.js"
));

require.define("/node_modules/reducers/node_modules/eventual/when.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar method = require(\"method\")\nvar when = method(\"when\")\n\nwhen.define(function(value, onRealize) {\n  return typeof(onRealize) === \"function\" ? onRealize(value) : value\n})\nwhen.define(Error, function(error, onRealize, onError) {\n  return typeof(onError) === \"function\" ? onError(error) : error\n})\n\nmodule.exports = when\n\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/when.js"
));

require.define("/node_modules/reducers/node_modules/eventual/defer.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar Eventual = require(\"./type\")\nvar defer = function defer() { return new Eventual() }\n\nmodule.exports = defer\n\n//@ sourceURL=/node_modules/reducers/node_modules/eventual/defer.js"
));

require.define("/node_modules/reducers/filter.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar reducer = require(\"./reducer\")\n\nvar filter = reducer(function filter(predicate, next, value, result) {\n  /**\n  Composes filtered version of given `source`, such that only items contained\n  will be once on which `f(item)` was `true`.\n\n  ## Example\n\n  var digits = filter([ 10, 23, 2, 7, 17 ], function(value) {\n    return value >= 0 && value <= 9\n  })\n  print(digits) // => < 2 7 >\n  **/\n  return predicate(value) ? next(value, result) :\n         result\n})\n\nmodule.exports = filter\n\n//@ sourceURL=/node_modules/reducers/filter.js"
));

require.define("/node_modules/reducers/reducer.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar reduce = require(\"reducible/reduce\")\nvar reducible = require(\"reducible/reducible\")\nvar isError = require(\"reducible/is-error\")\nvar end = require(\"reducible/end\")\n\n\nfunction reducer(process) {\n  /**\n  Convenience function to simplify definitions of transformation function, to\n  avoid manual definition of `reducible` results and currying transformation\n  function. It creates typical transformation function with a following\n  signature:\n\n      transform(source, options)\n\n  From a pure data `process` function that is called on each value for a\n  collection with following arguments:\n\n    1. `options` - Options passed to the resulting transformation function\n       most commonly that's a function like in `map(source, f)`.\n    2. `next` - Function which needs to be invoked with transformed value,\n       or simply not called to skip the value.\n    3. `value` - Last value emitted by a collection being reduced.\n    4. `result` - Accumulate value.\n\n  Function is supposed to return new, accumulated `result`. It may either\n  pass mapped transformed `value` and `result` to the `next` continuation\n  or skip it.\n\n  For example see `map` and `filter` functions.\n  **/\n  return function reducer(source, options) {\n    // When return transformation function is called with a source and\n    // `options`\n    return reducible(function reduceReducer(next, initial) {\n      // When actual result is \n      reduce(source, function reduceReducerSource(value, result) {\n        // If value is `end` of source or an error just propagate through,\n        // otherwise call `process` with all the curried `options` and `next`\n        // continuation function.\n        return value === end ? next(value, result) :\n               isError(value) ? next(value, result) :\n               process(options, next, value, result)\n      })\n    })\n  }\n}\n\nmodule.exports = reducer\n\n//@ sourceURL=/node_modules/reducers/reducer.js"
));

require.define("/node_modules/reducible/reducible.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar reduce = require(\"./reduce\")\nvar end = require(\"./end\")\nvar isError = require(\"./is-error\")\nvar isReduced = require(\"./is-reduced\")\nvar reduced = require(\"./reduced\")\n\nfunction Reducible(reduce) {\n  /**\n  Reducible is a type of the data-structure that represents something\n  that can be reduced. Most of the time it's used to represent transformation\n  over other reducible by capturing it in a lexical scope.\n\n  Reducible has an attribute `reduce` pointing to a function that does\n  reduction.\n  **/\n\n  // JS engines optimize access to properties that are set in the constructor's\n  // so we set it here.\n  this.reduce = reduce\n}\n\n// Implementation of `accumulate` for reducible, which just delegates to it's\n// `reduce` attribute.\nreduce.define(Reducible, function reduceReducible(reducible, next, initial) {\n  var result\n  // State is intentionally accumulated in the outer variable, that way no\n  // matter if consumer is broken and passes in wrong accumulated state back\n  // this reducible will still behave as intended.\n  var state = initial\n  try {\n    reducible.reduce(function forward(value) {\n      try {\n        // If reduce reduction has already being completed just return\n        // `result` that is last state boxed in `reduced`. That way anything\n        // trying to dispatch after it's closed or error-ed will just be handed\n        // a `reduced` `state` indicating last value and no intent of getting\n        // more values.\n        if (result) return result\n\n        // If value is an `error` (that also includes `end` of stream) we just\n        // throw and let `catch` block do the rest of the job.\n        if (value === end || isError(value)) throw value\n\n        // Otherwise new `state` is accumulated `by` forwarding a `value` to an\n        // actual `next` handler.\n        state = next(value, state)\n\n        // If new `state` is boxed in `reduced` than source should be stopped\n        // and no more values should be forwarded to a `next` handler. To do\n        // that we throw `end` and let `catch` block do the rest of the job.\n        if (isReduced(state)) throw end\n\n        // If code got that far then nothing special happened and `new` state is\n        // just returned back, to a consumer.\n        return state\n      }\n      // If `error` is thrown that may few things:\n      //\n      //  1. Last value dispatched was indicator of an error (that also includes\n      //     `end` of stream).\n      //  2. Provided `next` handler threw an exception causing stream failure.\n      //\n      // When this happens stream is either finished or error-ed, either way\n      // no new items should get through. There for last `state` is boxed with\n      // `reduced` and store as a `result` of this accumulation. Any subsequent\n      // attempts of providing values will just get it in return, hopefully\n      // causing source of value to get closed.\n      catch (error) {\n        if (isReduced(state)) {\n          result = state\n          state = result.value\n        } else {\n          result = reduced(state)\n        }\n        // Maybe we should console.error exceptions if such arise when calling\n        // `next` in the following line.\n        next(error, state)\n        return result\n      }\n    }, null)\n  } catch(error) {\n    next(error, state)\n  }\n})\n\nfunction reducible(reduce) {\n  return new Reducible(reduce)\n}\nreducible.type = Reducible\n\nmodule.exports = reducible\n\n//@ sourceURL=/node_modules/reducible/reducible.js"
));

require.define("/node_modules/reducers/map.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar reducer = require(\"./reducer\")\n\nvar map = reducer(function map(f, next, value, result) {\n  /**\n  Returns transformed version of given `source` where each item of it\n  is mapped using `f`.\n\n  ## Example\n\n  var data = [{ name: \"foo\" }, { name: \"bar\" }]\n  var names = map(data, function(value) { return value.name })\n  print(names) // => < \"foo\" \"bar\" >\n  **/\n  next(f(value), result)\n})\n\nmodule.exports = map\n\n//@ sourceURL=/node_modules/reducers/map.js"
));

require.define("/node_modules/reducers/reductions.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar reduce = require(\"reducible/reduce\")\nvar reducible = require(\"reducible/reducible\")\nvar end = require(\"reducible/end\")\nvar isError = require(\"reducible/is-error\")\n\nfunction reductions(source, f, initial) {\n  /**\n  Returns `reducible` collection of the intermediate values of the reduction\n  (as per reduce) of `source` by `f`, starting with `initial` value.\n\n  ## Example\n\n  var numbers = reductions([1, 1, 1, 1], function(accumulated, value) {\n    return accumulated + value\n  }, 0)\n  print(numbers) // => < 1 2 3 4 >\n  **/\n  return reducible(function reduceReductions(next, start) {\n    var state = initial\n    return reduce(source, function reduceReductionsSource(value, result) {\n      if (value === end) return next(end, result)\n      if (isError(value)) return next(value, result)\n      state = f(state, value)\n      return next(state, result)\n    }, start)\n  })\n}\n\nmodule.exports = reductions\n\n//@ sourceURL=/node_modules/reducers/reductions.js"
));

require.define("/node_modules/reducers/concat.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar reducible = require(\"reducible/reducible\")\nvar reduce = require(\"reducible/reduce\")\nvar end = require(\"reducible/end\")\n\nvar slicer = Array.prototype.slice\n\nfunction append(left, right) {\n  /**\n  Returns sequences of items in the `left` sequence followed by the\n  items in the `right` sequence.\n  **/\n  return reducible(function reduceConcatination(next, initial) {\n    reduce(left, function reduceLeft(value, result) {\n      return value === end ? reduce(right, next, result) :\n             next(value, result)\n    }, initial)\n  })\n}\n\nfunction concat(left, right /*, ...rest*/) {\n  /**\n  Returns a sequence representing the concatenation of the elements in the\n  supplied arguments, in the given order.\n\n  print(concat([ 1 ], [ 2, 3 ], [ 4, 5, 6 ])) // => <stream 1 2 3 4 5 6 />\n\n  **/\n  switch (arguments.length) {\n    case 1: return left\n    case 2: return append(left, right)\n    default: return slicer.call(arguments).reduce(append)\n  }\n}\n\nmodule.exports = concat\n\n//@ sourceURL=/node_modules/reducers/concat.js"
));

require.define("/node_modules/reducers/merge.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar reduce = require(\"reducible/reduce\")\nvar reducible = require(\"reducible/reducible\")\nvar end = require(\"reducible/end\")\nvar isError = require(\"reducible/is-error\")\n\nfunction merge(source) {\n  /**\n  Merges given collection of collections to a collection with items of\n  all nested collections. Note that items in the resulting collection\n  are ordered by the time rather then index, in other words if item from\n  the second nested collection is deliver earlier then the item\n  from first nested collection it will in appear earlier in the resulting\n  collection.\n\n  print(merge([ [1, 2], [3, 4] ]))  // => < 1 2 3 4 >\n  **/\n  return reducible(function accumulateMerged(next, initial) {\n    var state = initial\n    var open = 1\n\n    function forward(value) {\n      if (value === end) {\n        open = open - 1\n        if (open === 0) return next(end)\n      } else {\n        state = next(value, state)\n      }\n      return state\n    }\n\n\n    reduce(source, function accumulateMergeSource(nested) {\n      // If there is an error or end of `source` collection just pass it\n      // to `forward` it will take care of detecting weather it's error\n      // or `end`. In later case it will also figure out if it's `end` of\n      // result to and act appropriately.\n      if (nested === end) return forward(end)\n      if (isError(nested)) return forward(nested)\n      // If `nested` item is not end nor error just `accumulate` it via\n      // `forward` that keeps track of all collections that are bing forwarded\n      // to it.\n      open = open + 1\n      reduce(nested, forward, null)\n    }, initial)\n  })\n}\n\nmodule.exports = merge\n\n//@ sourceURL=/node_modules/reducers/merge.js"
));

require.define("/node_modules/reducers/capture.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar reducible = require(\"reducible/reducible\")\nvar reduce = require(\"reducible/reduce\")\nvar reduced = require(\"reducible/reduced\")\nvar isError = require(\"reducible/is-error\")\n\nfunction capture(source, recover) {\n  /**\n  Creates and returns safe version of given `source` sequence, by using\n  `recover` function to recover from errors that may occur while reducing\n  a `source`. This is a mechanism for error handling and recovery for streams\n  that representing IO operations like (XHR / WebSockets etc...) where errors\n  may occur.\n  **/\n  return reducible(function reduceCapture(next, initial) {\n    var failure = void(0)\n    reduce(source, function reduceCaptureSource(value, result) {\n      // If error has already being captured then return\n      if (failure) return failure\n      // If value is an error then continue accumulation of recovered\n      // sequence.\n      else if (isError(value)) {\n        failure = reduced(result)\n        reduce(recover(value, result), next, result)\n        return failure\n      }\n      // Otherwise just forward messages.\n      else return next(value, result)\n    }, initial)\n  })\n}\n\nmodule.exports = capture\n\n//@ sourceURL=/node_modules/reducers/capture.js"
));

require.define("/node_modules/reducers/delay.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar reducible = require(\"reducible/reducible\")\nvar reduce = require(\"reducible/reduce\")\nvar isReduced = require(\"reducible/is-reduced\")\nvar end = require(\"reducible/end\")\n\nfunction delay(source, ms) {\n  ms = ms || 6 // Minimum 6ms, as on less dispatch order becomes unreliable\n  return reducible(function reduceDelayed(next, result) {\n    var timeout = 0\n    var ended = false\n    reduce(source, function reduceDelaySource(value) {\n      setTimeout(function delayed() {\n        if (!ended) {\n          timeout = timeout - ms\n          result = next(value, result)\n          if (isReduced(result)) {\n            ended = true\n            next(end)\n          }\n        }\n      }, timeout = timeout + ms)\n      return result\n    })\n  })\n}\n\nmodule.exports = delay\n\n//@ sourceURL=/node_modules/reducers/delay.js"
));

require.define("/node_modules/reducers/drop-while.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar reducible = require(\"reducible/reducible\")\nvar reduce = require(\"reducible/reduce\")\nvar isError = require(\"reducible/is-error\")\nvar end = require(\"reducible/end\")\n\nfunction dropWhile(source, predicate) {\n  /**\n  Returns a sequence of the items in `source` starting from the first\n  item for which `predicate(item)` returns `false`.\n\n  ## Example\n\n  var numbers = dropWhile([ 2, 7, 10, 23 ], function(value) {\n    return value < 10\n  })\n  print(numbers)   // => < 10 23 >\n  **/\n  return reducible(function reduceDropWhile(next, initial) {\n    var dropped = false\n    reduce(source, function reduceDropWhileSource(value, result) {\n      // If value is end of collection or is an error (which also includes\n      // end of collection) just pass it through, `reducible` will take care\n      // of everything.\n      if (value === end) return next(value, result)\n      if (isError(value)) return next(value, result)\n\n      // If already dropped all the intended items (if `dropped` is already\n      // being set to `true` or if current predicate returns `false`). Then\n      // just keep on passing values.\n      if (dropped || (dropped = !predicate(value))) return next(value, result)\n\n      return result\n    }, initial)\n  })\n}\n\nmodule.exports = dropWhile\n\n//@ sourceURL=/node_modules/reducers/drop-while.js"
));

require.define("/node_modules/reducers/drop.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar reducible = require(\"reducible/reducible\")\nvar reduce = require(\"reducible/reduce\")\nvar isError = require(\"reducible/is-error\")\nvar end = require(\"reducible/end\")\n\nfunction drop(source, n) {\n  /**\n  Returns sequence of all `source`'s items after `n`-th one. If source contains\n  less then `n` items empty sequence is returned.\n\n  ## Example\n\n  print(drop([ 1, 2, 3, 4 ], 2))  // => <stream 3 4 />\n  print(drop([ 1, 2, 3 ], 5))     // => <stream />\n  **/\n\n  // If drop `<= 0` then optimize by returning source itself. If `Infinity`\n  // return empty.\n  if (n <= 0) return source\n  if (n === Infinity) return void(0)\n  return reducible(function reduceDrop(next, initial) {\n    var count = n\n    reduce(source, function reduceDropSource(value, result) {\n      // If value is end of collection or is an error (which also includes\n      // end of collection) just pass it through, `reducible` will take care\n      // of everything.\n      if (value === end) return next(value, result)\n      if (isError(value)) return next(value, result)\n      // If count of items has reached `0` just keep on passing values.\n      if (count === 0) return next(value, result)\n      // Otherwise just decrement count and return `result`.\n      count = count - 1\n      return result\n    }, initial)\n  })\n}\n\nmodule.exports = drop\n\n//@ sourceURL=/node_modules/reducers/drop.js"
));

require.define("/node_modules/reducers/take-while.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar reducer = require(\"./reducer\")\nvar end = require(\"reducible/end\")\n\n\nvar takeWhile = reducer(function takeWhile(predicate, next, value, result) {\n  /**\n  Returns a sequence of successive items from `source` while `predicate(item)`\n  returns `true`. `predicate` must be free of side-effects.\n\n  ## Example\n\n  var digits = takeWhile([ 2, 7, 10, 23 ], function(x) { return x < 10 })\n  print(digits)   // => < 2 7 >\n  **/\n  return predicate(value) ? next(value, result) :\n         // Predicate returned `false` just pass `end`. Reducer will take\n         // care of returning `reduced(result)` back.\n         next(end)\n})\n\nmodule.exports = takeWhile\n\n//@ sourceURL=/node_modules/reducers/take-while.js"
));

require.define("/node_modules/reducers/take.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar reducible = require(\"reducible/reducible\")\nvar reduce = require(\"reducible/reduce\")\nvar end = require(\"reducible/end\")\n\nfunction take(source, n) {\n  /**\n  Returns sequence of first `n` items of the given `source`. If `source`\n  contains less items than `n` then that's how  much items return sequence\n  will contain.\n\n  ## Example\n\n  print(take([ 1, 2, 3, 4, 5 ], 2))   // => < 1 2 >\n  print(take([ 1, 2, 3 ], 5))         // => < 1 2 3 >\n  **/\n\n  // If take `0` then optimize by returning an empty if less then `0`\n  // then just return `source` back.\n  if (n === 0) return void(0)\n  if (n < 0) return source\n  return reducible(function reduceTake(next, initial) {\n    // Capture `n` into count, since modifying `n` directly will have side\n    // effects on subsequent calls.\n    var count = n\n    reduce(source, function reduceTakeSource(value, result) {\n      count = count - 1\n      result = next(value, result)\n\n      // If we have not taken `n` items yet just pass result back. Otherwise\n      // pass `end` of stream to a consumer. Note `reducible` will return\n      // `reduced(result)` back signaling source it should stop.\n      return count > 0 ? result :\n             next(end)\n    }, initial)\n  })\n}\n\nmodule.exports = take\n\n//@ sourceURL=/node_modules/reducers/take.js"
));

require.define("/node_modules/reducers/hub.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar reduce = require(\"reducible/reduce\")\nvar reduced = require(\"reducible/reduced\")\nvar isReduced = require(\"reducible/is-reduced\")\nvar end = require(\"reducible/end\")\n\nvar input = \"input@\" + module.id\nvar consumers = \"consumers@\" + module.id\n\n\nvar isArray = Array.isArray\n\nfunction Hub(source) {\n  this[input] = source\n  this[consumers] = []\n}\n\nreduce.define(Hub, function reduceHub(hub, next, initial) {\n  // Enqueue new consumer into consumers array so that new\n  // values will be delegated to it.\n  hub[consumers].push({ next: next, state: initial })\n  // If source is not in the process of consumption than\n  // start it up.\n  if (!isOpen(hub)) open(hub)\n})\n\nfunction drain(consumers) {\n  while (consumers.length) {\n    var count = consumers.length\n    var index = 0\n    while (index < count) {\n      var consumer = consumers[index]\n      consumer.next(end, consumer.state)\n      index = index + 1\n    }\n    consumers.splice(0, count)\n  }\n}\n\nfunction dispatch(consumers, value) {\n  var count = consumers.length\n  var index = 0\n  while (index < count) {\n    var consumer = consumers[index]\n    var state = consumer.next(value, consumer.state)\n    // If consumer has finished accumulation remove it from the consumers\n    // list. And dispatch end of stream on it (maybe that should not be\n    // necessary).\n    if (isReduced(state)) {\n      consumers.splice(index, 1)\n      consumer.next(end, state.value)\n      // If consumer is removed than we decrease count as consumers array\n      // will contain less elements (unless of course more elements were\n      // added but we would like to ignore those).\n      count = count - 1\n    } else {\n      consumer.state = state\n      index = index + 1\n    }\n  }\n}\n\nfunction open(hub) {\n  var source = hub[input]\n  var reducers = hub[consumers]\n  hub[input] = null         // mark hub as open\n  reduce(source, function distribute(value) {\n    // If it's end of the source we close all the reducers including\n    // ones that subscribe as side effect.\n    if (value === end) drain(reducers)\n    // otherwise we dispatch value to all the registered reducers.\n    else dispatch(reducers, value)\n\n    // reducers will be empty if either source is drained or if all the\n    // reducers finished reductions. Either way we reset input back to\n    // source and return `reduced` marker to stop the reduction of\n    // source.\n    if (reducers.length === 0) {\n      hub[input] = source\n      return reduced()\n    }\n  })\n}\n\nfunction isOpen(hub) {\n  return hub[input] === null\n}\n\nfunction hub(source) {\n  /**\n  Take a reducible `source`, such as a `signal` and return a reducible that can\n  be consumed by many reducers.\n  **/\n  if (source === null) return null\n  if (source === void(0)) return null\n  return new Hub(source)\n}\nhub.isOpen = isOpen\nhub.type = Hub\n\nmodule.exports = hub\n\n//@ sourceURL=/node_modules/reducers/hub.js"
));

require.define("/node_modules/reducers/debug/print.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar reduce = require(\"reducible/reduce\")\nvar reducible = require(\"reducible/reducible\")\nvar end = require(\"reducible/end\")\nvar isError = require(\"reducible/is-error\")\n\nvar PREFIX = \"\\u200B\"\nvar OPEN = PREFIX + \"< \"\nvar CLOSE = PREFIX + \">\\n\"\nvar ERROR = PREFIX + \"\\u26A1 \"\nvar DELIMITER = PREFIX + \" \"\n\nvar SPECIALS = [ OPEN, CLOSE, ERROR, DELIMITER ]\n\nvar write = (function() {\n  if (typeof(process) !== \"undefined\" &&\n      typeof(process.stdout) !== \"undefined\" &&\n      typeof(process.stdout.write) === \"function\") {\n    var inspect = require(\"util\").inspect\n    var slicer = Array.prototype.slice\n    return function write() {\n      var message = slicer.call(arguments).map(function($) {\n        return SPECIALS.indexOf($) >= 0 ? $ : inspect($)\n      }).join(\"\")\n      process.stdout.write(message)\n    }\n  } else {\n    return console.log.bind(console)\n  }\n})()\n\nfunction print(source) {\n  var open = false\n  reduce(source, function reducePrintSource(value) {\n    if (!open) write(OPEN)\n    open = true\n\n    if (value === end) write(CLOSE)\n    else if (isError(value)) write(ERROR, value, DELIMITER, CLOSE)\n    else write(value, DELIMITER)\n  })\n}\n\nmodule.exports = print\n\n//@ sourceURL=/node_modules/reducers/debug/print.js"
));

require.define("util",Function(['require','module','exports','__dirname','__filename','process','global'],"var events = require('events');\n\nexports.print = function () {};\nexports.puts = function () {};\nexports.debug = function() {};\n\nexports.inspect = function(obj, showHidden, depth, colors) {\n  var seen = [];\n\n  var stylize = function(str, styleType) {\n    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n    var styles =\n        { 'bold' : [1, 22],\n          'italic' : [3, 23],\n          'underline' : [4, 24],\n          'inverse' : [7, 27],\n          'white' : [37, 39],\n          'grey' : [90, 39],\n          'black' : [30, 39],\n          'blue' : [34, 39],\n          'cyan' : [36, 39],\n          'green' : [32, 39],\n          'magenta' : [35, 39],\n          'red' : [31, 39],\n          'yellow' : [33, 39] };\n\n    var style =\n        { 'special': 'cyan',\n          'number': 'blue',\n          'boolean': 'yellow',\n          'undefined': 'grey',\n          'null': 'bold',\n          'string': 'green',\n          'date': 'magenta',\n          // \"name\": intentionally not styling\n          'regexp': 'red' }[styleType];\n\n    if (style) {\n      return '\\033[' + styles[style][0] + 'm' + str +\n             '\\033[' + styles[style][1] + 'm';\n    } else {\n      return str;\n    }\n  };\n  if (! colors) {\n    stylize = function(str, styleType) { return str; };\n  }\n\n  function format(value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (value && typeof value.inspect === 'function' &&\n        // Filter out the util module, it's inspect function is special\n        value !== exports &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      return value.inspect(recurseTimes);\n    }\n\n    // Primitive types cannot have properties\n    switch (typeof value) {\n      case 'undefined':\n        return stylize('undefined', 'undefined');\n\n      case 'string':\n        var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                                 .replace(/'/g, \"\\\\'\")\n                                                 .replace(/\\\\\"/g, '\"') + '\\'';\n        return stylize(simple, 'string');\n\n      case 'number':\n        return stylize('' + value, 'number');\n\n      case 'boolean':\n        return stylize('' + value, 'boolean');\n    }\n    // For some reason typeof null is \"object\", so special case here.\n    if (value === null) {\n      return stylize('null', 'null');\n    }\n\n    // Look up the keys of the object.\n    var visible_keys = Object_keys(value);\n    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;\n\n    // Functions without properties can be shortcutted.\n    if (typeof value === 'function' && keys.length === 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        var name = value.name ? ': ' + value.name : '';\n        return stylize('[Function' + name + ']', 'special');\n      }\n    }\n\n    // Dates without properties can be shortcutted\n    if (isDate(value) && keys.length === 0) {\n      return stylize(value.toUTCString(), 'date');\n    }\n\n    var base, type, braces;\n    // Determine the object type\n    if (isArray(value)) {\n      type = 'Array';\n      braces = ['[', ']'];\n    } else {\n      type = 'Object';\n      braces = ['{', '}'];\n    }\n\n    // Make functions say that they are functions\n    if (typeof value === 'function') {\n      var n = value.name ? ': ' + value.name : '';\n      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';\n    } else {\n      base = '';\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = ' ' + value.toUTCString();\n    }\n\n    if (keys.length === 0) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        return stylize('[Object]', 'special');\n      }\n    }\n\n    seen.push(value);\n\n    var output = keys.map(function(key) {\n      var name, str;\n      if (value.__lookupGetter__) {\n        if (value.__lookupGetter__(key)) {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Getter/Setter]', 'special');\n          } else {\n            str = stylize('[Getter]', 'special');\n          }\n        } else {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Setter]', 'special');\n          }\n        }\n      }\n      if (visible_keys.indexOf(key) < 0) {\n        name = '[' + key + ']';\n      }\n      if (!str) {\n        if (seen.indexOf(value[key]) < 0) {\n          if (recurseTimes === null) {\n            str = format(value[key]);\n          } else {\n            str = format(value[key], recurseTimes - 1);\n          }\n          if (str.indexOf('\\n') > -1) {\n            if (isArray(value)) {\n              str = str.split('\\n').map(function(line) {\n                return '  ' + line;\n              }).join('\\n').substr(2);\n            } else {\n              str = '\\n' + str.split('\\n').map(function(line) {\n                return '   ' + line;\n              }).join('\\n');\n            }\n          }\n        } else {\n          str = stylize('[Circular]', 'special');\n        }\n      }\n      if (typeof name === 'undefined') {\n        if (type === 'Array' && key.match(/^\\d+$/)) {\n          return str;\n        }\n        name = JSON.stringify('' + key);\n        if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n          name = name.substr(1, name.length - 2);\n          name = stylize(name, 'name');\n        } else {\n          name = name.replace(/'/g, \"\\\\'\")\n                     .replace(/\\\\\"/g, '\"')\n                     .replace(/(^\"|\"$)/g, \"'\");\n          name = stylize(name, 'string');\n        }\n      }\n\n      return name + ': ' + str;\n    });\n\n    seen.pop();\n\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n      numLinesEst++;\n      if (cur.indexOf('\\n') >= 0) numLinesEst++;\n      return prev + cur.length + 1;\n    }, 0);\n\n    if (length > 50) {\n      output = braces[0] +\n               (base === '' ? '' : base + '\\n ') +\n               ' ' +\n               output.join(',\\n  ') +\n               ' ' +\n               braces[1];\n\n    } else {\n      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n    }\n\n    return output;\n  }\n  return format(obj, (typeof depth === 'undefined' ? 2 : depth));\n};\n\n\nfunction isArray(ar) {\n  return ar instanceof Array ||\n         Array.isArray(ar) ||\n         (ar && ar !== Object.prototype && isArray(ar.__proto__));\n}\n\n\nfunction isRegExp(re) {\n  return re instanceof RegExp ||\n    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');\n}\n\n\nfunction isDate(d) {\n  if (d instanceof Date) return true;\n  if (typeof d !== 'object') return false;\n  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);\n  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);\n  return JSON.stringify(proto) === JSON.stringify(properties);\n}\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\nexports.log = function (msg) {};\n\nexports.pump = null;\n\nvar Object_keys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) res.push(key);\n    return res;\n};\n\nvar Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {\n    var res = [];\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n};\n\nvar Object_create = Object.create || function (prototype, properties) {\n    // from es5-shim\n    var object;\n    if (prototype === null) {\n        object = { '__proto__' : null };\n    }\n    else {\n        if (typeof prototype !== 'object') {\n            throw new TypeError(\n                'typeof prototype[' + (typeof prototype) + '] != \\'object\\''\n            );\n        }\n        var Type = function () {};\n        Type.prototype = prototype;\n        object = new Type();\n        object.__proto__ = prototype;\n    }\n    if (typeof properties !== 'undefined' && Object.defineProperties) {\n        Object.defineProperties(object, properties);\n    }\n    return object;\n};\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object_create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (typeof f !== 'string') {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(exports.inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j': return JSON.stringify(args[i++]);\n      default:\n        return x;\n    }\n  });\n  for(var x = args[i]; i < len; x = args[++i]){\n    if (x === null || typeof x !== 'object') {\n      str += ' ' + x;\n    } else {\n      str += ' ' + exports.inspect(x);\n    }\n  }\n  return str;\n};\n\n//@ sourceURL=util"
));

require.define("events",Function(['require','module','exports','__dirname','__filename','process','global'],"if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === 'function'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]'\n    }\n;\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n  this.emit('newListener', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = list.indexOf(listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n//@ sourceURL=events"
));

require.define("/node_modules/reducers/into.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar fold = require(\"./fold\")\n\nfunction into(source, buffer) {\n  /**\n  Adds items of given `reducible` into\n  given `array` or a new empty one if omitted.\n  **/\n  return fold(source, function foldInto(value, result) {\n    result.push(value)\n    return result\n  }, buffer || [])\n}\n\nmodule.exports = into\n\n//@ sourceURL=/node_modules/reducers/into.js"
));

require.define("/node_modules/dom-reduce/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./index.js\"}\n//@ sourceURL=/node_modules/dom-reduce/package.json"
));

require.define("/node_modules/dom-reduce/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nexports.event = require(\"./event\")\n\n//@ sourceURL=/node_modules/dom-reduce/index.js"
));

require.define("/node_modules/dom-reduce/event.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/* vim:set ts=2 sw=2 sts=2 expandtab */\n/*jshint asi: true undef: true es5: true node: true browser: true devel: true\n         forin: true latedef: false globalstrict: true */\n\n\"use strict\";\n\nvar reducible = require(\"reducible/reducible\")\nvar isReduced = require(\"reducible/is-reduced\")\n\nfunction open(target, type, options) {\n  /**\n  Capture events on a DOM element, converting them to a reducible channel.\n  Returns a reducible channel.\n\n  ## Example\n\n      var allClicks = open(document.documentElement, \"click\")\n      var clicksOnMyTarget = filter(allClicks, function (click) {\n        return click.target === myTarget\n      })\n  **/\n  var capture = options && options.capture || false\n  return reducible(function reducDomEvents(next, result) {\n    function handler(event) {\n      result = next(event, result)\n      //  When channel is marked as accumulated, remove event listener.\n      if (isReduced(result)) {\n        if (target.removeEventListener)\n          target.removeEventListener(type, handler, capture)\n        else\n          target.detachEvent(type, handler, capture)\n      }\n    }\n    if (target.addEventListener) target.addEventListener(type, handler, capture)\n    else target.attachEvent(\"on\" + type, handler)\n  })\n}\n\nmodule.exports = open\n\n//@ sourceURL=/node_modules/dom-reduce/event.js"
));

require.define("/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./main.js\"}\n//@ sourceURL=/package.json"
));

require.define("/node_modules/event/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./event.js\"}\n//@ sourceURL=/node_modules/event/package.json"
));

require.define("/node_modules/event/send.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar method = require(\"method\")\nvar send = method(\"send\")\n\nmodule.exports = send\n\n//@ sourceURL=/node_modules/event/send.js"
));

require.define("/node_modules/interactivate/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./interactivate.js\"}\n//@ sourceURL=/node_modules/interactivate/package.json"
));

require.define("/node_modules/interactivate/render.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar method = require(\"method\")\nvar util = require(\"util\")\n\n\n// Render function takes arbitrary data structure and returns something\n// that can visually represent it.\nvar render = method(\"render\")\n\nrender.define(function(value) {\n  return util.inspect(value)\n})\n\nrender.define(Error, function(error) {\n  return String(error)\n})\n\nrender.define(Element, function(element) {\n  return element\n})\n\nmodule.exports = render\n\n//@ sourceURL=/node_modules/interactivate/render.js"
));

require.define("/node_modules/interactivate/main.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar interactivate = require(\"./interactivate\")\n\nvar CodeMirror = require(\"./code-mirror\")\nvar activeLine = require(\"./code-mirror/active-line\")\nvar persist = require(\"./code-mirror/persist\")\n\nvar editor = CodeMirror(document.body, {\n  electricChars: true,\n  autofocus: true,\n  theme: \"solarized dark\",\n  mode: \"javascript\",\n})\n\n// Enable interactive mode for this editor.\ninteractivate(editor)\n// Enable active line highlighting.\nactiveLine(editor)\n// Enable persistence of the editor buffer.\npersist(editor)\n\n//@ sourceURL=/node_modules/interactivate/main.js"
));

require.define("/node_modules/interactivate/interactivate.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar diff = require(\"diffpatcher/diff\")\nvar patch = require(\"diffpatcher/patch\")\nvar render = require(\"./render\")\nvar CodeMirror = require(\"./code-mirror\")\n\nCodeMirror.defaults.interactiveEnabled = true\nCodeMirror.defaults.interactiveKey = \"Cmd-Enter\"\nCodeMirror.defaults.interactiveSpeed = 300\nCodeMirror.defaults.interactiveSeparator = /^\\/\\/ \\=\\>[^\\n]*$/m\n\n\nvar makeView = (function() {\n  var uri = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAMCAYAAABBV8wuAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAGpJREFUeNpi/P//PwM2wMSAA7CACEYggLKZgfgvEP8BCYAwKxALAjEPEH8B4g9MUI5IWlqayevXr9eCaCBfGGSSVnJysu/Xr1+fAx3y/9u3by9BfIb29vZCmCAMgCQZ/+NwL07nUlECIMAAMr41sxvv6oEAAAAASUVORK5CYII=\"\n  var template = document.createElement(\"div\")\n\n  template.style.marginLeft = \"-10px\"\n  template.style.padding = \"0\"\n  template.style.position = \"relative\"\n  template.style.marginRight = \"-10px\"\n  template.style.whiteSpace = \"normal\"\n\n  template.innerHTML = [\n    \"  <div class='cm-live-output-border-top'> </div>\",\n    \"  <div class='cm-live-output-box'>\",\n    \"    <h1 class='cm-live-output-head'>Out[0]</h1>\",\n    \"    <pre class='cm-live-output-body'>Hello output</pre>\",\n    \"  </div>\",\n    \"  <div class='cm-live-output-border-bottom'></div>\",\n  ].join(\"\\n\")\n\n    template.querySelector(\".cm-live-output-border-top\").setAttribute(\"style\", [\n    \"position: relative\",\n    \"z-index: 2\",\n    \"height: 12px\",\n    \"background-clip: padding-box\",\n    \"background: url('\" + uri + \"') top right repeat-x\"\n  ].join(\";\"))\n\n  template.querySelector(\".cm-live-output-border-bottom\").setAttribute(\"style\", [\n    \"position: relative\",\n    \"z-index: 2\",\n    \"height: 12px\",\n    \"background-clip: padding-box\",\n    \"background: url('\" + uri + \"') top left repeat-x\",\n    \"-webkit-transform: rotate(180deg)\",\n    \"transform: rotate(180deg)\"\n  ].join(\";\"))\n\n  template.querySelector(\".cm-live-output-box\").setAttribute(\"style\", [\n    \"-moz-box-shadow: 0 0 30px -2px #000\",\n    \"-webkit-box-shadow: 0 0 30px -2px #000\",\n    \"box-shadow: 0 0 30px -2px #000\",\n    \"color: black\",\n    \"background: white\",\n    \"position: relative\",\n    \"padding: 10px\",\n    \"margin: 0px\",\n    \"display: -webkit-box\",\n    \"display: -moz-box\",\n    \"display: -moz-flex;\",\n    \"-webkit-box-flex: 2\",\n    \"-moz-box-flex: 2\",\n    \"box-flex: 2\",\n    \"width: 100%\"\n  ].join(\";\"))\n\n  template.querySelector(\".cm-live-output-head\").setAttribute(\"style\", [\n    \"-webkit-box-flex: 0\",\n    \"-moz-box-flex: 0\",\n    \"box-flex: 0\",\n    \"margin: 0 10px 0 0\",\n    \"whitespace: pre\",\n    \"color: white\",\n    \"text-shadow: 0px 1px 5px #000\"\n  ].join(\";\"))\n  template.querySelector(\".cm-live-output-body\").setAttribute(\"style\", [\n    \"-webkit-box-flex: 1\",\n    \"-moz-box-flex: 1\",\n    \"box-flex: 1\",\n    \"padding-right: 30px\"\n  ].join(\";\"))\n\n  return function makeView(editor, line) {\n    var view = template.cloneNode(true)\n\n    editor.markText({ line: line, ch: 0 },\n                    { line: line + 1, ch: 0 },\n                    { atomic: true, replacedWith: view })\n\n    return view\n  }\n})()\n\nmodule.exports = function interactive(editor) {\n  var state = {}\n  var View = {}\n  var Out = {}\n  var id = -1\n\n  window.Out = Out\n\n  function apply(delta) {\n    Object.keys(delta).forEach(function(id) {\n      var In = delta[id]\n      editor.operation(function() {\n        if (In === null) {\n          delete Out[id]\n          delete View[id]\n        } else {\n          var view = View[id] || (View[id] = makeView(editor, In.line))\n          try {\n            Out[id] = window.eval(In.source)\n          } catch (error) {\n            Out[id] = error\n          }\n          var label = view.querySelector(\".cm-live-output-head\")\n          var code = view.querySelector(\".cm-live-output-body\")\n          label.textContent = \"Out[\" + id + \"] = \"\n          code.innerHTML = \"<span></span>\"\n          var out = render(Out[id])\n          if (out instanceof Element)\n            code.replaceChild(out, code.children[0])\n          else\n            code.textContent = out\n        }\n      })\n    })\n    state = patch(state, delta)\n  }\n\n  function calculate() {\n    var source = editor.getValue()\n    var separator = editor.getOption(\"interactiveSeparator\")\n    var sections = source.split(separator)\n    sections.pop()\n    var update = Object.keys(sections).reduce(function(result, index) {\n      var source = sections[index]\n      var out = result.out + source.split(\"\\n\").length - 1\n      result.out = out\n      result.state[index] = {\n        source: source,\n        line: out\n      }\n\n      return result\n    }, { out: 0, state: {} })\n\n    var delta = diff(state, update.state)\n    apply(delta)\n  }\n\n  editor.on(\"change\", function(editor, change) {\n    clearTimeout(id)\n    id = setTimeout(calculate, editor.getOption(\"interactiveSpeed\"), change)\n  })\n\n  function print(editor) {\n    if (!editor.getOption(\"interactiveEnabled\")) throw CodeMirror.Pass\n    editor.operation(function() {\n      var cursor = editor.getCursor()\n      editor.replaceSelection(\"\\n\\n// =>\\n\")\n      editor.setCursor({ line: cursor.line + 3, ch: 0 })\n    })\n  }\n\n  CodeMirror.keyMap.default[editor.getOption(\"interactiveKey\")] = print\n}\n\n//@ sourceURL=/node_modules/interactivate/interactivate.js"
));

require.define("/node_modules/diffpatcher/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./index.js\"}\n//@ sourceURL=/node_modules/diffpatcher/package.json"
));

require.define("/node_modules/diffpatcher/diff.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar method = require(\"method\")\n\n// Method is designed to work with data structures representing application\n// state. Calling it with a state should return object representing `delta`\n// that has being applied to a previous state to get to a current state.\n//\n// Example\n//\n// diff(state) // => { \"item-id-1\": { title: \"some title\" } \"item-id-2\": null }\nvar diff = method(\"diff\")\n\n// diff between `null` / `undefined` to any hash is a hash itself.\ndiff.define(null, function(from, to) { return to })\ndiff.define(undefined, function(from, to) { return to })\ndiff.define(Object, function(from, to) {\n  return calculate(from, to || {}) || {}\n})\n\nfunction calculate(from, to) {\n  var diff = {}\n  var changes = 0\n  Object.keys(from).forEach(function(key) {\n    changes = changes + 1\n    if (!(key in to) && from[key] != null) diff[key] = null\n    else changes = changes - 1\n  })\n  Object.keys(to).forEach(function(key) {\n    changes = changes + 1\n    var previous = from[key]\n    var current = to[key]\n    if (previous === current) return (changes = changes - 1)\n    if (typeof(current) !== \"object\") return diff[key] = current\n    if (typeof(previous) !== \"object\") return diff[key] = current\n    var delta = calculate(previous, current)\n    if (delta) diff[key] = delta\n    else changes = changes - 1\n  })\n  return changes ? diff : null\n}\n\ndiff.calculate = calculate\n\nmodule.exports = diff\n\n//@ sourceURL=/node_modules/diffpatcher/diff.js"
));

require.define("/node_modules/diffpatcher/patch.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar method = require(\"method\")\nvar rebase = require(\"./rebase\")\n\n// Method is designed to work with data structures representing application\n// state. Calling it with a state and delta should return object representing\n// new state, with changes in `delta` being applied to previous.\n//\n// ## Example\n//\n// patch(state, {\n//   \"item-id-1\": { completed: false }, // update\n//   \"item-id-2\": null                  // delete\n// })\nvar patch = method(\"patch\")\npatch.define(Object, function patch(hash, delta) {\n  return rebase({}, hash, delta)\n})\n\nmodule.exports = patch\n\n//@ sourceURL=/node_modules/diffpatcher/patch.js"
));

require.define("/node_modules/diffpatcher/rebase.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nfunction rebase(result, parent, delta) {\n  Object.keys(parent).forEach(function(key) {\n    // If `parent[key]` is `null` it means attribute was deleted in previous\n    // update. We skip such properties as there is no use in keeping them\n    // around. If `delta[key]` is `null` we skip these properties too as\n    // the have being deleted.\n    if (!(parent[key] == null || (key in delta && delta[key] == null)))\n      result[key] = parent[key]\n  }, result)\n  Object.keys(delta).forEach(function(key) {\n    if (key in parent) {\n      var current = delta[key]\n      var previous = parent[key]\n      if (current === previous) current = current\n      // If `delta[key]` is `null` it's delete so we just skip property.\n      else if (current == null) current = current\n      // If value is of primitive type (function or regexps should not\n      // even be here) we just update in place.\n      else if (typeof(current) !== \"object\") result[key] = current\n      // If previous value associated with this key was primitive\n      // and it's mapped to non primitive\n      else if (typeof(previous) !== \"object\") result[key] = current\n      else result[key] = rebase({}, previous, current)\n    } else {\n      result[key] = delta[key]\n    }\n  })\n  return result\n}\n\nmodule.exports = rebase\n\n//@ sourceURL=/node_modules/diffpatcher/rebase.js"
));

require.define("/node_modules/interactivate/code-mirror/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nmodule.exports = CodeMirror\n\n//@ sourceURL=/node_modules/interactivate/code-mirror/index.js"
));

require.define("/node_modules/interactivate/code-mirror/active-line.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nmodule.exports = function activeLinePlugin(editor) {\n  /**\n  Takes code-mirror editor and enables active-line highlighting\n  **/\n\n  var activeLine = editor.addLineClass(0, \"background\", \"activeline\")\n  editor.on(\"cursorActivity\", function onCursorActivity() {\n    var line = editor.getLineHandle(editor.getCursor().line)\n    if (line != activeLine) {\n      editor.removeLineClass(activeLine, \"background\", \"activeline\")\n      activeLine = editor.addLineClass(line, \"background\", \"activeline\")\n    }\n  })\n}\n\n//@ sourceURL=/node_modules/interactivate/code-mirror/active-line.js"
));

require.define("/node_modules/interactivate/code-mirror/persist.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar address = window.location.href\n\nmodule.exports = function persist(editor) {\n  /**\n  Takes editor and enables persists changes to the buffer across the sessions.\n  **/\n\n  editor.setValue(localStorage[address] || \"\")\n  editor.on(\"change\", function() {\n    localStorage[address] = editor.getValue()\n  })\n}\n\n//@ sourceURL=/node_modules/interactivate/code-mirror/persist.js"
));

require.define("/node_modules/event/event.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar send = require(\"./send\")\nvar reduce = require(\"reducible/reduce\")\nvar isReduced = require(\"reducible/is-reduced\")\nvar isError = require(\"reducible/is-error\")\nvar reduced = require(\"reducible/reduced\")\nvar end = require(\"reducible/end\")\n\n// `Event` is data type representing a stream of values that can be dispatched\n// manually in an imperative style by calling `send(event, value)`\nfunction Event() {}\n\n// `Event` type has internal property of for aggregating `watchers`. This\n// property has a unique name and is intentionally made non-enumerable (in\n// a future it will be a private names\n// http://wiki.ecmascript.org/doku.php?id=harmony:private_name_objects) so\n// that it's behavior can not be tempered.\nvar reducer = \"watchers@\" + module.id\nvar state = \"state@\" + module.id\nvar ended = \"ended@\" + module.id\nObject.defineProperty(Event.prototype, state, {\n  value: void(0), enumerable: false, configurable: false, writable: true\n})\nObject.defineProperty(Event.prototype, reducer, {\n  value: void(0), enumerable: false, configurable: false, writable: true\n})\nObject.defineProperty(Event.prototype, ended, {\n  value: false, enumerable: false, configurable: false, writable: true\n})\n\n\n\n// ## send\n//\n// `Event` type implements `send` as a primary mechanism for dispatching new\n//  values of the given `event`. All of the `watchers` of the `event` will\n//  be invoked in FIFO order. Any new `watchers` added in side effect to this\n//  call will not be invoked until next `send`. Note at this point `send` will\n//  return `false` if no watchers have being invoked and will return `true`\n//  otherwise, although this implementation detail is not guaranteed and may\n//  change in a future.\nsend.define(Event, function sendEvent(event, value) {\n  // Event may only be reduced by one consumer function.\n  // Other data types built on top of signal may allow for more consumers.\n  if (event[ended]) return reduced()\n  if (value === end || isError(value)) event[ended] = true\n\n  var next = event[reducer]\n  if (next) {\n    var result = next(value, event[state])\n    if (isReduced(result) || event[ended])\n      event[reducer] = event[state] = void(0)\n    else event[state] = result\n  }\n})\n\nreduce.define(Event, function(event, next, initial) {\n  // Event may only be reduced by one consumer function.\n  // Other data types built on top of signal may allow for more consumers.\n  if (event[reducer] || event[ended])\n    return next(Error(\"Event is already reduced\"), initial)\n  event[reducer] = next\n  event[state] = initial\n})\n\nfunction event() {\n  /**\n  Function creates new `Event` that can be `watched` for a new values `send`-ed\n  on it. Also `send` function can be used on returned instance to send new\n  values.\n\n  ## Example\n\n      var e = event()\n\n      send(e, 0)\n\n      reduce(e, function(index, value) {\n        console.log(\"=>\", index, value)\n        return index + 1\n      }, 0)\n\n      send(e, \"a\") // => 0 \"a\"\n      send(e, \"b\") // => 0 \"b\"\n  **/\n  return new Event()\n}\nevent.type = Event\n\nmodule.exports = event\n\n//@ sourceURL=/node_modules/event/event.js"
));

require.define("/widget.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar event = require(\"event\")\nvar send = require(\"event/send\")\nvar fold = require(\"reducers/fold\")\nvar render = require(\"interactivate/render\")\n\n\nfunction Widget(model, input, open, swap) {\n  this.model = model\n  this.input = input\n  this.open = open\n  this.swap = swap\n}\nrender.define(Widget, function(widget) {\n  var view = widget.open(widget.model)\n  fold(widget.input, function(state) {\n    widget.swap(state, view)\n  })\n  return view\n})\n\nfunction widget(open, swap) {\n  return function (model, input) {\n    return new Widget(model, input, open, swap)\n  }\n}\n\nmodule.exports = widget\n\n//@ sourceURL=/widget.js"
));

require.define("/main.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar reducers = require(\"reducers\")\nvar dom = require(\"dom-reduce\")\nvar widget = require(\"./widget\")\n\nvar interactive = require(\"interactivate/main\")\n\n//@ sourceURL=/main.js"
));
require("/main.js");
