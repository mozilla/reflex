"use strict";

var collection = require("./collection")

var State = require("./state")

var patch = require("diffpatcher/patch")



var filter = require("reducers/filter")
var map = require("reducers/map")
var hub = require("reducers/hub")
var merge = require("reducers/merge")

var has = require("oops/has")
var field = require("oops/field")
var dictionary = require("oops/dictionary")

var keys = Object.keys
var isArray = Array.isArray


function unit(schema) {
  /**
  Takes schema of the input and creates a reactor that will operate on the
  input of that shape. Returned reactor destructures input update and
  distributes it across associated reactors in the provided mapping. Output
  returned by each reactor are combined to unified input that has same schema.

  This enables structuring application components in a logical units that can
  handle scoped state changes without being concerned by others.

  ## Example

      var reactor = unit({
        items: [{
          name: property("textContent"),
          text: property("value"),
          hidden: attribute("hidden")
        }]
        count: {
          complete: property("textContent"),
          pending: property("textContent")
        }
      })
  **/

  // If schema is a function then it's already a reactor.
  if (typeof(schema) === "function") return schema
  // If schema is an array then it's represents a collection of items with in.
  if (isArray(schema)) return collection(unit(schema[0]))

  // Map schema to reactors that handle each node with in it.
  var reactors = keys(schema).reduce(function(reactors, id) {
    reactors[id] = unit(schema[id])
    return reactors
  }, {})


  return function reactor(options) {
    /**
    Reactor function takes `input` in form of state changes for the unit it
    bound to and returns `output` of state changes caused by interactions
    on that unit. Reactor distributes changes across nested reactors.
    If this reactor is not given an `input` it will assume to be a top level
    reactor and will feed of it's own `output` as all the state changes are
    caused by it.

    Note that reactor is lazy, it will not reactions until `output` returned
    by it is reduced.
    **/

    var target = options.target
    var context = options.context || []

    // Note that `map` is intentionally used instead of `Object.map` since
    // it's lazy, which allows overriding `input` with created `output` before
    // it will be destructured.
    var outputs = map(keys(schema), function(id) {
      // Narrow down input to a `changes` that modify state of the
      // data mapped to `id` attribute.
      var changes = filter(input, has(id))
      // Fork changes to a destructured input.
      var fork = map(changes, field(id))

      // Create an output using reactor that reacts on changes for the data
      // mapped to an `id`. Output is state changes cased by interaction on
      // component represented by a reactor.
      var reactor = reactors[id]
      var output = reactor({
        input: fork,
        target: target,
        context: context.concat(id)
      })

      // Restructure `output` back to a shape / schema matching the input.
      return map(output, dictionary(id))
    })

    // Merge all outputs and multiplex it, so that consumers down the flow
    // would share transformations from this point on.
    var output = hub(merge(outputs))

    // If input is not given then this is a root / application unit
    // there for all the inputs are generated by itself.
    var input = options.input || output

    return output
  }
}

module.exports = unit
